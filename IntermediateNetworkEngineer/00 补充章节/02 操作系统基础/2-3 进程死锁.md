# 2-3 进程死锁

死锁是指两个或两个以上的进程在执行过程中，因**争夺资源**而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

理解：有8个打印机，3个进程，如果每个进程需要4台打印机：

- 假设为进程1分配3台，为进程2分配3台，为进程3分配2台，那么3个进程都不能正常执行，互相等待，无法执行下去
- 假设为进程1分配4台，为进程2分配4台，为进程3分配0台，那么进程3只需等待进程1或进程2执行结束释放资源即获得资源，开始正常执行

可把系统资源分为两类：

- 可剥夺性资源：资源分配给进程后**可以被高优先级的进程剥夺**，如CPU、主存。这类资源**不会产生死锁**
- 不可剥夺性资源：分配给进程后**只能在进程用完后才释放的资源**，如磁带机、打印机等。

## 死锁发生的四个条件

- **互斥条件**：即一个资源每次只能被一个进程使用

- **保持和等待条件**：有一个进程获得了一些资源，但因正在请求其他资源而被阻塞(获得的资源不够)

- **不剥夺条件**：就是系统不是抢占式的，进程已获得的资源在未使用完之前，不能剥夺，只能在使用完后由自己释放(不可剥夺性资源即可构成这类条件)

- **环路等待条件**：若干个进程形成环型链，每个都占用对方要申请的下一个资源。如下图P表示进程，R表示资源

  ![image-20240408212439596](https://img.yatjay.top/md/image-20240408212439596.png)

## 解决死锁的策略

- 摒弃“保持和等待条件”条件
- 摒弃“不剥夺“条件
- 摒弃“环路等待”条件



死锁避免：避免是指进程在每次申请资源时判断这些操作是否安全，典型避免死锁的算法是**银行家算法**

死锁检测：判断系统是否处于死锁状态，如果是，则执行死锁解除策略

死锁解除：就是剥夺，即将资源强行分配给别的进程

<font color = red>**记住**</font>：不产生死锁的条件：
$$
资源数 ≥ 并发进程数 *（每个进程所需资源-1）+ 1
$$
即
$$
资源数  ≥ n（m-1）+1
$$
其中，n表示并发进程数量，m表示每个进程所需资源数量

## 例题

![image-20240408211506149](https://img.yatjay.top/md/image-20240408211506149.png)

解析：这里的i即上面公式中的m，可列出不等式8 ≥ 3(i - 1) + 1解得i ≤ 3.33

则有

- i = 0、1、2、3时不会产生死锁，即不会发生死锁的 i 的最大值为3
- i ≥ 4 时会发生死锁，因此会发生死锁的 i 的最小值为4