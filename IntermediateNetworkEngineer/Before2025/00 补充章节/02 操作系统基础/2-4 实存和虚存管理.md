# 2-4 实存和虚存管理(内存管理)

## 实存管理

存储管理的任务是存储空间的分配与回收。现代操作系统通常有：

- 单一连续分配方法：不对内存空间进行分区，适用于单任务操作系统如DOS，进程执行时把操作系统使用之外的内存空间都分配给该进程使用
- 固定分区分配方法：对内存空间进行分区适用于多任务操作系统，进程执行时把操作系统使用之外的内存空间分成大小不同区域，区域分配完成后固定不变，供进程使用。缺点是固定不变的分片会产生内存碎片，造成内存空间浪费如需要用6K，分配的区域只有8K大小的，2K空间就浪费了
- 可变分区分配方法：内存空间分成大小不等的区域，根据用户要求动态分配。进程需要20K就分配20K

![image-20240408214239452](https://img.yatjay.top/md/image-20240408214239452.png)

## 分配算法

在可变分区分配方式中，当新作业申请内存时，有4种分配算法：

- **最佳适应法**：选择等于或最**接近作业大小**的内存进行分配。可以减少碎片，但同时也可能带来更多小得无法再用的碎片
- **最差适应法**：选择整个主存中**最大**的内存自由区进行分配
- **首次适应法**：从内存低地址开始，寻找第一个可用（即大于等于作业需求的内存）的自由区。这种方法可实现快速分配，缩短查找时间
- **循环首次适应算法**：上面首次适应法每次都要从头查找，循环首次适应是首次适应法的改进，从上次分配的地址继续向下匹配

## 虚拟内存管理(了解)

虚拟内存：将硬盘空间当做内存来使用

由于内存的大小总是有限的，如果都采用“实存管理”那么大于总物理内存的作业就无法运行。

为了解决这个问题，可行的方法就是**用外存来换取内存**，这就是虚拟存储系统。它通过将运行进程访问的地址（逻辑地址，虚拟地址）与主存的物理地址（实地址）分开，**使提供大于物理地址的逻辑地址空间**成为可能

建立虚拟地址和实地址之间的对应关系、实现转换的工作就称为"虚存管理”

### 虚存的组织

常见的有分页技术，分段技术、段页式技术三种(掌握分页和分段，段页式为二者相加)

![image-20240408214424400](https://img.yatjay.top/md/image-20240408214424400.png)

- 分段式划分的段不定长，分页式划分的页是定长的

## 案例分析

![image-20240408214443767](https://img.yatjay.top/md/image-20240408214443767.png)

解析：选择B

- 页内地址从0~12共13位，可供分配的页内地址共[最大地址 - 最小地址 +1] = (2^13 - 1) - 0 +1 = 2 ^13 = 8 * 2^10 = 8K 即可供分配的页内地址共 2^13 = 8K(13位，每位有0/1这2种取值)
- 页号从13~23共11位：可供分配的页号共2^11 = 2048，且页是定长的，每个段最大允许2048个页，超过的话页号不够编号
- 段号从24~31共8位：可供分配的段号共2^8 = 256，且段是不定长的，最多有256个段

![image-20240408214500194](https://img.yatjay.top/md/image-20240408214500194.png)

解析：选择D。题意理解：该进程有4个页面即需要4个内存块，系统只分配了3个内存块

- 把进程分成一页一页的叫一页，把物理存储分为一块一块的叫物理块(或者本题叫存储块)，进程执行的时候把进程的一页放到物理块的一块中。

- 当页号(物理块)不够了，但是进程还没有完成，那怎么办？又不能让程序停止，所以可以(只是可以，还有其他淘汰方法)把之前占用着页号(物理块)的但是后面又不会再用(或者最晚才会再次使用)的淘汰掉，腾出位置来。

本题中，进程P需要三个存储块来存放4个页面，如果一个页面就放一个存储块，很明显是不够的。题中给出的页号为0、2、3都在内存中，占满了分配的三块储存块，所以题干中说，访问到的页面1不在内存中。现在进程需要页面1的时候出现了缺页中断信号，需要去淘汰一个已经在内存中被占用的页号，拿来给1使用。书上介绍了4种淘汰原则(置换算法)，**本题的淘汰原则：依次为最近没有访问的、没有修改的**。因为访问位都是1无法判断，所以判断修改位，可以看到3号的修改位为0，表示没有修改过，所以本题选D。

> 章节4.3.6。
>
> 书上面的“请求分页管理的实现”和“页面置换算法”中例题已经说得非常通俗易懂了，应该说只要看了就能理解(不过书上它表中的物理块那一行没写全，导致有歧义不好理解，其实它表中竖着的“物理块”三个字应该扩展成“进程访问到当前页号时当前所占用的所有物理块”)。主要考察页面置换算法。
>
> 最佳置换算法：把最长时间不被使用的页面，或者以后都不会再访问的给淘汰掉。性能最好，实现困难。
>
> 比如操作系统仅给进程分配了三个物理块，此进程会多次请求分配物理块，当请求到一个页面号，这个页面号没在内存中(没在内存中才需要淘汰一个腾出位置)，但是可以预见的，前期请求的一个页号以后都不会使用了，那么就把这个页号中占用的页号，替换成新的就OK了(书上没说会被替换，说原来的会被淘汰，不过顾名思义可以理解)。
>
> 还有其他三个置换算法，详情请自行查看(括号里的内容，如果理解有困难，请结合书上的例题表格理解)：
>
> 先进先出(就是把物理块号排在最末尾的慢慢淘汰，实现最简单)算法、
>
> 最近最少未使用(LRU，这个翻译不太好，可以理解成当前已经在内存中所有的页号，很长时间没有使用的淘汰掉。此算法和先进先出差不多，只有一个特殊的地方：在当前访问页号在内存中的时候，也就是不需要淘汰的时候，需要把当前访问页号提前到所有的页号的最前面，表示该页号是最最近才访问的，后面的物理块都是访问过的，老的，排后面的就也就和先进先出完全一样，慢慢的淘汰掉)算法、
>
> 最近未用置换算法(NUR，没有例题，请自行了解)。