**前言：**在现在越来越安全的体系下，SQL Injection 这类漏洞已经很难在安全性很高地站点出现，比如一些不错的.NET 或 JAVA 的框架基本上都是参数化传递用户输入，直接封死注入攻击。 而在非php的web安全中最有威力的攻击主要有两种，第一种是SQL Injection，第二种便是上传绕过漏洞。（php 的还有远程文件包含或代码注入漏洞)。一般只要能注册普通用户，时常都能找到上传头像或附件之类的地方，这些地方就是好的突 破点，只要有办法绕过上传验证，并找到一句话木马的 web 路径基本上就能搞下这个站点。

<img src="https://img.yatjay.top/md/202203251657484.png" style="zoom:80%;" />

# 涉及知识

## 什么是文件上传漏洞

一些Web应用程序中允许上传图片，文本或者其他资源到指定的位置，文件上传漏洞就是利用这些可以上传的地方将恶意代码植入到服务器中，再通过URL去访问以执行代码

## 文件上传的原理

网站Web应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型，此时攻击者就可以上传一个webshell到一个Web可访问的目录上，并将恶意文件传递给如PHP解释器去执行，之后就可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理，服务器命令执行等恶意操作。还有一部分是攻击者通过Web服务器的解析漏洞来突破Web应用程序的防护

## 文件上传漏洞的危害

文件可以自定义，可以成为webshell，通过文件上传来上传网站后门，直接获取网站权限，属于高危漏洞。上传漏洞与SQL注入或 XSS相比 , 其风险更大 。可以获取数据库信息，可以对服务器提权，获取内网权限

## 文件上传漏洞的查找及判断

### 黑盒查找

黑盒查找即对方网站情况事先不知道，需要目录、文件扫描获取

#### 网站后台

进入网站后台不一定获得网站权限，可以从后台获取网站权限(后台权限不等于网站权限)

后台拿webshell：即从后台权限拿到网站webshell的过程

#### 会员中心

通过头像图片上传，测试是否存在文件上传漏洞

#### 文件扫描 

使用工具扫描出后台路径

### 白盒查找 

白盒查找即事先知道网站源码，进行审计

通过代码分析到上传漏洞，查找文件上传功能

## 文件上传漏洞需要注意的地方

对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期的测试。

### 文件上传漏洞的利用思路


![img](https://img.yatjay.top/md/202203251657222.png)

常规类：扫描获取上传，会员中心上传，后台系统上传，各种途径上传

CMS类：已知CMS源码，搜索已知CMS漏洞

编辑器类：ckeditor、fckeditor、kindeditor、xxxeditor，也是搜索相关编辑器漏洞

配合解析漏洞下的文件类型后门：可以通过解析漏洞，上传包含后门代码的图片

### 文件上传在实际应用中的方式

####  方法一

- 先直接传一个PHP，实战先传马。

- 实战先传一个正常的图片，看看有无返回存储地址。

- 如果能直接上传并解析，已离成功不远。

####  方法二

- 先传一个shell，然后进行修改。

- `connect-Type:image/jpeg`，看看是否可以进行绕过，如果不行，在上传内容添加`GIF89a`

- 当然上传了还得看是否能够被解析为php，所有的上传都要考虑是否能够被解析。

####  方法三

- 上传一个abc.abcd，目的只是为了查看是否为白名单还是黑名单绕过。

- 黑名单限制一般为此文件类型不允许上传，考虑双写，大小写，空格，php2,php3,php4,php5,phtphtml,等方式

- 我们继续上传一个/htaccess文件，.htaccess文件能够设置服务器的解析文件的格式，匹配到dudu就已php的格式来解析，继而上传马

- 如果说.htaccess不能上传，接下来上传一个.user.ini，继而上传一个马

####  方法四

​	如果白名单限制上传

- 考虑00截断上传
- 文件包含漏洞+图片马

- 文件包含漏洞+二次渲染+图片马

####  方法五

- 上传的东西是否被服务器很快的删除或者移除，或者说上传成功，但是无法访问，就得考虑条件竞争。

- 以上均不行，考虑逻辑层面的思路。

# 演示案例

## 案例1：常规文件上传地址的获取

该案例演示，旨在说明如何寻找到文件上传漏洞点，找到上传点后可进行初步上传测试

使用谷歌语法搜索`inurl:upload.php`

![img](https://img.yatjay.top/md/202203251657368.png)

![img](https://img.yatjay.top/md/202203251658741.png)

搜索上传界面

![img](https://img.yatjay.top/md/202203251658723.png)

![img](https://img.yatjay.top/md/202203251658012.png)

![img](https://img.yatjay.top/md/202203251658149.png)

使用工具扫描，如下图中扫描结果中出现了kindeditor，可以测试是否有编辑器类型的文件上传漏洞

![img](https://img.yatjay.top/md/202203251658836.png)

## 案例2：不同格式下的文件类型后门测试

假设上传了一个test的后门文件，其内容是输出phpinfo()函数

上传文件名为test.php可以访问并执行成功如下

![](https://img.yatjay.top/md/202203251658965.png)

上传文件名为test.jpg，访问无法得到期望结果

![](https://img.yatjay.top/md/202203251658582.png)

不要妄想通过一个图片你能带着你的后门来控制网站。直接改格式有时候并没有什么用

因为对于php脚本，服务器调用php程序解析执行；对于jpg文件，服务器调用图片显示程序显示

因此**什么格式代码就用什么格式去执行。**除非存在文件包含、文件解析等漏洞，如下面的例子所示。

## 案例3：配合Nginx解析漏洞下的文件类型后门测试

[Nginx解析漏洞靶场环境地址](https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/)

Nginx解析漏洞复现。

版本信息：

- Nginx 1.x 最新版
- PHP 7.x最新版

由此可知，该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞。

![img](https://img.yatjay.top/md/202203251658208.png)

照片使用文本编辑器打开，在末尾写入代码，为防止解析不到，可以多写几遍

![](https://img.yatjay.top/md/202203251703091.png)

然后将照片上传，发现上传成功

![img](https://img.yatjay.top/md/202203251658523.png)

通过路径打开文件，正常显示，所以写入代码没有被执行，正是由于上传的是图片格式而不是PHP代码格式，所以无法执行

![img](https://img.yatjay.top/md/202203251700016.png)

在路径后面加上`1.php `发现可以执行了，这并不是说这样加了都可以，是因为这里有Nginx解析漏洞， 对方服务器中间件在文件解析上的出现了混乱。

解析漏洞的出现也有其条件，其利用成功与否要看有没有解析漏洞

有文件解析漏洞的话可以按这种方法利用解析漏洞在访问图片文件后加`……picture.png/xxx.php`执行到php代码，没有解析漏洞的话就无法实现 ，实际环境中99%的上传入口无法上传脚本文件。

![img](https://img.yatjay.top/md/202203251700446.png)

## 案例4：本地文件上传漏洞靶场环境搭建测试

项目地址：https://github.com/c0ny1/upload-labs

本环境不涉及数据库操作，将文件放到网站根目录即可访问

访问第一关，发现对文件名有过滤

![](https://img.yatjay.top/md/202203251700434.png)

前端过滤：过滤代码直接在前端浏览器上执行(不安全)

后端过滤：发送到对方服务器脚本里面，由后端脚本在去验证去判断(更安全)

如果是前端代码对上传文件后缀名进行过滤，有以下2种思路绕过

第一个思路：处理掉前端验证代码

1. 前端删除这段代码即可，推荐此方法
2. 使用插件禁用前端js脚本的执行，不推荐，有可能禁用掉其他有用的js脚本

查看网页源代码发现是前端对文件名进行过滤

![](https://img.yatjay.top/md/202203251700534.png)

这时候我们在自己本地新建一个文件（存放我们的第一关，防止误删其他重要代码），在代码中我们将验证部分删掉，同时加上对应的提交位置

![](https://img.yatjay.top/md/202203251700308.png)

添加上传跳转的php文件位置？？？

![](https://img.yatjay.top/md/202203251700417.png)

![](https://img.yatjay.top/md/202203251700375.png)

进行上传操作，在对应文件看到php文件，成功上传！

![](https://img.yatjay.top/md/202203251700706.png)

![](https://img.yatjay.top/md/202203251700376.png)

第二个思路：利用burp抓包进行修改,将后缀直接改成php即可实现上传脚本文件操作

![](https://img.yatjay.top/md/202203251700580.png)

**注意：**burp在有些情况下抓不到包，本案例中抓得到是因为代码中前端提交的部分和后端php代码进行了交互；如果仅单纯使用js代码过滤，不和php后端进行交互，它是在客户端运行，不会将数据发送到服务器上，则无法通过burp抓包并修改。

## 案例5：某CMS及CVE编号文件上传漏洞测试

### 某CMS文件上传漏洞简介

FineCMS公益版v5.0存在会员中心，在上传头像界面可能存在文件上传漏洞

![img](https://img.yatjay.top/md/202203251700173.png)

![img](https://img.yatjay.top/md/202203251700613.png)

上传操作是**使用JS进行验证，在浏览器前端完成**，所以抓不到包

![img](https://img.yatjay.top/md/202203251700687.png)

点击上图中的保存按钮，burp才出现了数据包，说明保存操作才与后端开始交互

![](https://img.yatjay.top/md/202203251700806.png)

改成PHP

![](https://img.yatjay.top/md/202203251700440.png)

上传时显示上传失败，显示的是失败，错误提示里面没有路径的回显

![img](https://img.yatjay.top/md/202203251700342.png)

但是此时我们去网站后台查看，会发现PHP文件已经上传成功了

![](https://img.yatjay.top/md/202203251700714.png)

但是常规渗透过程中我们会判断为文件上传失败，进而放弃这个漏洞，文件上传漏洞测试失败。

识别到使用的是FineCMS，所以去搜索一些关于FineCMS的漏洞

![img](https://img.yatjay.top/md/202203251700079.png)

![img](https://img.yatjay.top/md/202203251701078.png)

根据前辈经验进行尝试

![img](https://img.yatjay.top/md/202203251701098.png)

查找uid，发现cookies中含有uid（也可以爆破查找uid）

![img](https://img.yatjay.top/md/202203251701546.png)

对后缀进行修改

![img](https://img.yatjay.top/md/202203251701241.png)

修改uid为3

![img](https://img.yatjay.top/md/202203251701891.png)

上传时可能出现404，再上传一次上传成功

![img](https://img.yatjay.top/md/202203251701694.png)

webshell访问，可以看到php文件执行成功

![](https://img.yatjay.top/md/202203251705440.png)

### 某CMS文件上传漏洞实战测试

FOFA查找此漏洞相关站点，第一个结果可以成功访问

![image-20240620230443360](https://img.yatjay.top/md/image-20240620230443360.png)

注册账号，进入用户个人界面

![image-20240620230653069](https://img.yatjay.top/md/image-20240620230653069.png)

点击上传头像，并上传一张图片一句话木马，图片宜色彩简单，文件较小，否则容易php解析出错。

制作一句话图片马如下

![image-20240620235731150](https://img.yatjay.top/md/image-20240620235731150.png)

这里我们上传了一张几乎为纯白色的图片马

![image-20240620234649858](https://img.yatjay.top/md/image-20240620234649858.png)

开启Burp抓包，点击上面页面中的保存按钮后，查看抓包结果

![image-20240620234929810](https://img.yatjay.top/md/image-20240620234929810.png)

将请求体开头处的png改成php后放行数据包，界面显示如下

![image-20240620235019098](https://img.yatjay.top/md/image-20240620235019098.png)

实际返回数据包如下

![image-20240620235119166](https://img.yatjay.top/md/image-20240620235119166.png)

实际上此时图片马已经上传成功，尝试访问上传地址（搜索漏洞复现原理可知实际上传地址），需要注意先取到当前用户的uid值

![image-20240620235336936](https://img.yatjay.top/md/image-20240620235336936.png)

使用取到的uid值构造访问路径，可见头像文件已经被作为php文件解析了

![image-20240620235238962](https://img.yatjay.top/md/image-20240620235238962.png)

此时使用菜刀工具连接，可以拿到webshell

![image-20240620235543126](https://img.yatjay.top/md/image-20240620235543126.png)

通过服务器目录可知，这是某测试者在公网搭建的漏洞测试学习环境

漏洞复现完毕

### Weblogic 任意文件上传漏洞（CVE-2018-2894）

启动vulhub靶场环境，获取账号密码

![img](https://img.yatjay.top/md/202203251701945.png)

访问IP:7001端口

192.168.64.137:7001/console

登录账号密码

![img](https://img.yatjay.top/md/202203251701269.png)

点击base_domin

![img](https://img.yatjay.top/md/202203251701905.png)

点击高级-->勾选"启用web服务测试页"

![img](https://img.yatjay.top/md/202203251701174.png)

![img](https://img.yatjay.top/md/202203251701287.png)

![img](https://img.yatjay.top/md/202203251701344.png)

![img](https://img.yatjay.top/md/202203251701885.png)

上传后查看数据包，其中有时间戳

![img](https://img.yatjay.top/md/202203251701781.png)

![img](https://img.yatjay.top/md/202203251701244.png)



![img](https://img.yatjay.top/md/202203251702475.png)

文件上传成功

![img](https://img.yatjay.top/md/202203251701843.png)

因此如果不知道第三方应用相关的漏洞，即使登录到后台，也不能正确利用。以上的CMS和CVE的文件上传漏洞，都受到其他代码的影响，需要一定条件才能利用其文件上传漏洞。不是单纯的仅仅通过文件上传代码进行漏洞利用，常规测试无法测试出来，因此对这些漏洞一定要进行分类，不分类就做不了。

# 课程小结

1. 是什么文件格式，服务器就会按照什么文件格式解析，比如.jpg中插入.php脚本代码，执行jpg图片时无法触发脚本代码；
2. 有解析漏洞时，就能实现任意文件格式的解析，比如jpg中插入php脚本代码，若存在文件解析漏洞，执行jpg图片时可以触发脚本代码；
3. 搭建靶场
4. 网站CMS、第三方应用、编辑器这三类在测试中，和常规通过抓包进行文件上传漏洞测试是不一样的，因此要对这类漏洞进行归类

# 涉及资源

https://github.com/c0ny1/upload-labs

