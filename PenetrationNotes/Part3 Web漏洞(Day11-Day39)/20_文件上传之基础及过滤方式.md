**前言：**在现在越来越安全的体系下，SQL Injection 这类漏洞已经很难在安全性很高地站点出现，比如一些不错的.NET 或 JAVA 的框架基本上都是参数化传递用户输入，直接封死注入攻击。 而在非php的web安全中最有威力的攻击主要有两种，第一种是SQL Injection，第二种便是上传绕过漏洞。（php 的还有远程文件包含或代码注入漏洞)。一般只要能注册普通用户，时常都能找到上传头像或附件之类的地方，这些地方就是好的突 破点，只要有办法绕过上传验证，并找到一句话木马的 web 路径基本上就能搞下这个站点。

<img src="https://gitee.com/YatJay/image/raw/master/img/202202172124316.png" style="zoom:80%;" />

# 涉及知识

## 什么是文件上传漏洞

凡是存在文件上传的地方均有可能存在文件上传漏洞，关于上传文件操作的时候对方代码写的是否完整、是否安全，一旦疏忽了某个地方可能会造成文件上传漏洞。

## 文件上传的原理

网站Web应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型，此时攻击者就可以上传一个webshell到一个Web可访问的目录上，并将恶意文件传递给如PHP解释器去执行，之后就可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理，服务器命令执行等恶意操作。还有一部分是攻击者通过Web服务器的解析漏洞来突破Web应用程序的防护

## 文件上传漏洞的危害

文件可以自定义，可以成为webshell，通过文件上传来上传网站后门，直接获取网站权限，属于高危漏洞。上传漏洞与SQL注入或 XSS相比 , 其风险更大 。可以获取数据库信息，可以对服务器提权，获取内网权限

## 文件上传漏洞的查找及判断

### 黑盒查找

黑盒查找即对方网站情况事先不知道，需要目录、文件扫描获取

#### 网站后台

进入网站后台不一定获得网站权限，可以从后台获取网站权限(后台权限不等于网站权限)

百度——后台拿webshell即从后台权限拿到网站webshell

#### 会员中心

通过图片上传

#### 文件扫描 

使用工具扫描出后台路径

### 白盒查找 

白盒查找即事先知道网站源码，进行审计

通过代码分析到上传漏洞，查找文件上传功能

## 文件上传漏洞需要注意的地方

对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期的测试。

### 文件上传漏洞的利用思路


![img](https://gitee.com/YatJay/image/raw/master/img/202202172122680.png)

常规类：扫描获取上传，会员中心上传，后台系统上传，各种途径上传

CMS类：已知CMS源码，搜索已知cms漏洞

编辑器类：ckeditor,fckeditor,kindeditor,xxxeditor，也是搜索相关编辑器漏洞

配合解析漏洞下的文件类型后门：可以通过解析漏洞，上传包含后门代码的图片

### 文件上传在实际应用中的方式

####  方法一

- 先直接传一个PHP，实战先传马。

- 实战先传一个正常的图片，看看有无返回存储地址。

- 如果能直接上传并解析，已离成功不远。

####  方法二

- 先传一个shell，然后进行修改。

- connect-Type:image/jpeg，看看是否可以进行绕过，如果不行，在上传内容添加GIF89a

- 当然上传了还得看是否能够被解析为php，所有的上传都要考虑是否能够被解析。

####  方法三

- 上传一个abc.abcd，目的只是为了查看是否为白名单还是黑名单绕过。

- 黑名单限制一般为此文件类型不允许上传，考虑双写，大小写，空格，php2,php3,php4,php5,phtphtml,等方式

- 我们继续上传一个/htaccess文件，.htaccess文件能够设置服务器的解析文件的格式，匹配到dudu就已php的格式来解析，继而上传马

- 如果说.htaccess不能上传，接下来上传一个.user.ini，继而上传一个马

####  方法四

​	如果白名单限制上传

- 考虑00截断上传
- 文件包含漏洞+图片马

- 文件包含漏洞+二次渲染+图片马

####  方法五

- 上传的东西是否被服务器很快的删除或者移除，或者说上传成功，但是无法访问，就得考虑条件竞争。

- 以上均不行，考虑逻辑层面的思路。

# 演示案例

## 常规文件上传地址的获取

使用谷歌语法搜索inurl:upload.php

![img](https://gitee.com/YatJay/image/raw/master/img/202202172138205.png)

![img](https://gitee.com/YatJay/image/raw/master/img/202202172138247.png)

搜索上传界面

![img](https://gitee.com/YatJay/image/raw/master/img/202202172138042.png)

![img](https://gitee.com/YatJay/image/raw/master/img/202202172138242.png)

![img](https://gitee.com/YatJay/image/raw/master/img/202202172138828.png)

使用工具扫描

![img](https://cdn.nlark.com/yuque/0/2021/png/1272951/1622130185771-2984bedb-5095-4215-81f7-6056372785aa.png)

## 不同格式下的文件类型后门测试

假设上传了一个test的后门文件，其内容是输出phpinfo()函数

上传文件名为test.php可以访问并执行成功如下

![](https://gitee.com/YatJay/image/raw/master/img/202202172150993.png)

上传文件名为test.jpg，访问无法得到期望结果

![](https://gitee.com/YatJay/image/raw/master/img/202202172151146.png)

不要妄想通过一个图片你能带着你的后门来控制网站。直接改格式有时候并没有什么用

因为对于php脚本，服务器调用php程序解析执行；对于jpg文件，服务器调用图片显示程序显示

因此**什么格式代码就用什么格式去执行。**除非存在文件包含、文件解析等漏洞，如下面的例子所示。

## 配合解析漏洞下的文件类型后门测试


nginx解析漏洞

https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/

![img](https://gitee.com/YatJay/image/raw/master/img/202202172206727.png)

照片使用文本编辑器打开，在末尾写入代码，为防止解析不到，可以多写几遍

![](https://gitee.com/YatJay/image/raw/master/img/202203161040708.png)

然后将照片上传，发现上传成功

![img](https://gitee.com/YatJay/image/raw/master/img/202202172206828.png)

通过路径打开文件，正常显示，所以写入代码没有被执行，正是由于上传的是图片格式而不是PHP代码格式，所以无法执行

![img](https://gitee.com/YatJay/image/raw/master/img/202202172206276.png)

在路径后面加上1.php 发现可以执行了，这并不是说这样加了都可以，是因为这里有Nginx解析漏洞， 对方在文件解析上的出现了混乱。

解析漏洞的出现也有其条件。其利用成功与否要看有没有解析漏洞

有的话可以按这种方法利用解析漏洞在访问图片文件后加`……picture.png/xxx.php`执行到php代码

没有解析漏洞的话就无法实现 ，%99的上传入口无法上传脚本文件。

![img](https://gitee.com/YatJay/image/raw/master/img/202202172206226.png)

## 本地文件上传漏洞靶场环境搭建测试

项目地址：https://github.com/c0ny1/upload-labs

本环境不涉及数据库操作，将文件放到网站根目录即可访问

访问第一关，发现对文件名有过滤

![](https://gitee.com/YatJay/image/raw/master/img/202202172233818.png)

前端过滤：过滤代码直接在浏览器上执行(不安全)

后端过滤：发送到对方服务器脚本里面，由后端脚本在去验证去判断(更安全)

如果是前端代码对上传文件后缀名进行过滤，有以下2中方法绕过

1. 前端删除这段代码即可，推荐此方法
2. 使用插件禁用前端js脚本的执行，不推荐，有可能禁用掉其他有用的js脚本

查看网页源代码发现是前端对文件名进行过滤

![](https://gitee.com/YatJay/image/raw/master/img/202202172235717.png)

这时候我们在自己本地新建一个文件（存放我们的第一关，防止误删其他重要代码），在代码中我们将验证部分删掉，同时加上对应的提交位置

![](https://gitee.com/YatJay/image/raw/master/img/202202172251584.png)

==添加上传跳转的php文件位置？？？？？==

![](https://gitee.com/YatJay/image/raw/master/img/202202172251152.png)

![](https://gitee.com/YatJay/image/raw/master/img/202202172251224.png)

进行上传操作，在对应文件看到php文件，成功上传！

![](https://gitee.com/YatJay/image/raw/master/img/202202172251155.png)

![](https://gitee.com/YatJay/image/raw/master/img/202202172251164.png)

第二个思路：利用burp抓包进行修改,将后缀直接改成php即可实现上传脚本文件操作

![](https://gitee.com/YatJay/image/raw/master/img/202202172252016.png)

**注意：**burp在有些情况下是抓不到包，这里抓的到是因为代码中提交的部分。比如使用js代码，它是在本地运行，不会将数据发送到服务器上。

## 某CMS及CVE编号文件上传漏洞测试

### 某CMS 

存在会员中心，在上传头像界面可能存在文件上传漏洞

![img](https://gitee.com/YatJay/image/raw/master/img/202202190921215.png)

![img](https://gitee.com/YatJay/image/raw/master/img/202202190921501.png)

上传操作是**使用JS进行验证，在浏览器前端完成**。所以抓不到包

![img](https://gitee.com/YatJay/image/raw/master/img/202202190921050.png)

点击保存出现了数据包

![](https://gitee.com/YatJay/image/raw/master/img/202202190927152.png)

改成PHP

![](https://gitee.com/YatJay/image/raw/master/img/202202190927724.png)

上传时显示上传失败，显示的是失败，错误提示里面没有路径的回显

![img](https://gitee.com/YatJay/image/raw/master/img/202202190922309.png)

但是此时我们去网站后台查看，会发现PHP文件已经上传成功了。

![](https://gitee.com/YatJay/image/raw/master/img/202202190937983.png)

但是常规渗透过程中我们会判断为文件上传失败，进而放弃这个漏洞，文件上传漏洞测试失败。

识别到使用的是FineCMS，所以去搜索一些关于FineCMS的漏洞

![img](https://gitee.com/YatJay/image/raw/master/img/202202190922373.png)

![img](https://gitee.com/YatJay/image/raw/master/img/202202190922668.png)

根据前辈经验进行尝试

![img](https://gitee.com/YatJay/image/raw/master/img/202202190922599.png)

查找uid，发现cookies中含有uid。（也可以爆破）

![img](https://gitee.com/YatJay/image/raw/master/img/202202190922294.png)

对后缀进行修改

![img](https://gitee.com/YatJay/image/raw/master/img/202202190922366.png)

修改uid为3

![img](https://gitee.com/YatJay/image/raw/master/img/202202190923939.png)

上传时可能出现404，再上传一次上传成功

![img](https://gitee.com/YatJay/image/raw/master/img/202202190923526.png)

webshell访问，可以看到php文件执行成功

![](https://gitee.com/YatJay/image/raw/master/img/202202190947468.png)

### Weblogic 任意文件上传漏洞（CVE-2018-2894）

启动vulhub靶场环境，获取账号密码

![img](https://gitee.com/YatJay/image/raw/master/img/202202190955228.png)

访问IP:7001端口

192.168.64.137:7001/console

登录账号密码

![img](https://gitee.com/YatJay/image/raw/master/img/202202190956331.png)

点击base_domin

![img](https://gitee.com/YatJay/image/raw/master/img/202202190956524.png)

点击高级-->勾选"启用web服务测试页"

![img](https://gitee.com/YatJay/image/raw/master/img/202202190956646.png)

![img](https://gitee.com/YatJay/image/raw/master/img/202202190957093.png)

![img](https://gitee.com/YatJay/image/raw/master/img/202202190957602.png)

![img](https://gitee.com/YatJay/image/raw/master/img/202202190957928.png)

上传后查看数据包，其中有时间戳

![img](https://gitee.com/YatJay/image/raw/master/img/202202190957881.png)

![img](https://gitee.com/YatJay/image/raw/master/img/202202190957528.png)



![img](https://gitee.com/YatJay/image/raw/master/img/202202190957029.png)

文件上传成功

![img](https://gitee.com/YatJay/image/raw/master/img/202202190957851.png)

因此如果不知道第三方应用相关的漏洞，即使登录到后台，也不能正确利用。以上的CMS和CVE的文件上传漏洞，都受到其他代码的影响，需要一定条件才能利用其文件上传漏洞。不是单纯的仅仅通过文件上传代码进行漏洞利用，常规测试无法测试出来，因此对这些漏洞一定要进行分类，不分类就做不了。

# 课程小结

1. 是什么文件格式，服务器就会按照什么文件格式解析，比如.jpg中插入.php脚本代码，执行jpg图片时无法触发脚本代码；
2. 有解析漏洞时，就能实现任意文件格式的解析，比如jpg中插入php脚本代码，若存在文件解析漏洞，执行jpg图片时可以触发脚本代码；
3. 搭建靶场
4. 网站CMS、第三方应用、编辑器这三类在测试中，和常规通过抓包进行文件上传漏洞测试是不一样的，因此要对这类漏洞进行归类

# 涉及资源

https://github.com/c0ny1/upload-labs

