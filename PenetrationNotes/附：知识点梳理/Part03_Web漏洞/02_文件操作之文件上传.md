# 文件上传之基础及过滤方式

## 原理

网站Web应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型，此时攻击者就可以上传一个webshell到一个Web可访问的目录上，并将恶意文件传递给如PHP解释器去执行，之后就可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理，服务器命令执行等恶意操作。

## 查找

### 黑盒查找

1. 网站后台
2. 会员中心的图片上传
3. 文件扫描：使用工具扫出后台路径

### 白盒查找

分析代码，查找文件上传功能代码

## 文件上传漏洞分类及利用思路

![202202172122680](https://img.yatjay.top/md/202203261111663.png)

### 文件上传在实际应用中的方式

####  方法一

- 先直接传一个PHP，实战先传马。

- 实战先传一个正常的图片，看看有无返回存储地址。

- 如果能直接上传并解析，已离成功不远。

####  方法二

- 先传一个shell，然后进行修改。

- connect-Type:image/jpeg，看看是否可以进行绕过，如果不行，在上传内容添加GIF89a

- 当然上传了还得看是否能够被解析为php，所有的上传都要考虑是否能够被解析。

####  方法三

- 上传一个abc.abcd，目的只是为了查看是否为白名单还是黑名单绕过。

- 黑名单限制一般为此文件类型不允许上传，考虑双写，大小写，空格，php2,php3,php4,php5,phtphtml,等方式

- 我们继续上传一个/htaccess文件，.htaccess文件能够设置服务器的解析文件的格式，匹配到dudu就已php的格式来解析，继而上传马

- 如果说.htaccess不能上传，接下来上传一个.user.ini，继而上传一个马

####  方法四

​	如果白名单限制上传

- 考虑00截断上传
- 文件包含漏洞+图片马

- 文件包含漏洞+二次渲染+图片马

####  方法五

- 上传的东西是否被服务器很快的删除或者移除，或者说上传成功，但是无法访问，就得考虑条件竞争。
- 以上均不行，考虑逻辑层面的思路。

## 







# 文件上传之后端黑白名单绕过

## 文件上传常见验证方式

### 前端验证后缀名



### 后缀名验证：

1. 后缀名黑名单
2. 后缀名白名单



### 文件类型验证：检查MIME信息

Content-Type称之为MIME信息，一些网站是通过这个值来判断文件是何种格式。

### 文件头验证：检查文件内容头信息

通过文件头部信息，判断文件的格式

### 







# 文件上传之内容逻辑数组绕过







# 文件上传之解析漏洞和编辑器安全

略

# 文件上传之WAF绕过及安全修复

## 常见文件上传WAF绕过方法——关键在提交数据包的文件名filename处

### 垃圾数据溢出——影响WAF匹配

上传文件时修改数据包，向其中填充大量垃圾数据，WAF在匹配黑白名单时就会受影响以至于匹配出错，因而导致非法的文件上传成功

1. filename的内容进行溢出
2. name(表单名)与filename(文件名)之间进行溢出
3. 大量垃圾数据后加“;”进行分隔：Content-Disposition与name之间的垃圾数据加上分号可绕过安全狗。
4. name与filename之间的垃圾数据也可绕过。

### 符号变异(‘  “  ;)——防匹配

们猜测安全狗检测文件后缀名的机制：安全狗只检查双引号内的参数值，看一对双引号内的后缀是否合法，基于此，我们尝试如下绕过方法：

1. 不写引号：`filename=x.php`
2. 改为单引号括起：`filename='x.php'`
3. 去掉一半双引号使之不闭合：`filename="x.php`
4. 去掉一半双引号使之不闭合：`filename=x.php"`
5. 构造一对双引号内的参数值，令其合法：`filename="asdf"x.php`

### 数据截断(%00  ;  换行)——防匹配

WAF的过滤代码也是使用编程语言来编写，一些通用的代码中的截断符号(比如%00、;、换行)能够使得匹配语句被截断，从而影响匹配结果

1. 分号截断：filename=“a.jpg;.php”;
2. 斜杠截断：filename=“xxx/x.php”或filename=“/x.php”
3. %00截断：filename=“a.php%00.jpg”
4. 换行截断：filename= <br/>" <br/>x <br/>. <br/>p <br/>h <br/>p <br/>"

### 重复数据(参数多次)——防匹配

安全狗的过滤代码有可能是单次过滤、多次过滤、循环过滤、递归过滤，因此可以把文件名这个参数多写几次，当过滤次数有限时，可能绕过过滤机制，如以下写法

- filename=“Content-Disposition: form-data; name=“upload_file”;x.php” -> 成功上传x.php（借助白名单） 
- filename=“x.jpg”;filename=“x.jpg”;…filename=“x.php”;

### 配合Fuzz字典

手工测试的话有点麻烦，可以借助写好的字典配合BP进行批量测试，先在本地测试，然后在真实环境进行测试，以防封IP。

不一定能成功，成败与否的关键是字典的好坏

## 文件上传修复方案

1. 后端验证：采用服务端验证模式，避免只使用前端过滤
2. 后缀检测：基于黑名单，白名单过滤
3. MIME 检测：基于上传自带类型检测 
4. 内容检测：文件头，完整性检测 
5. 自带函数过滤：参考 uploadlabs 函数 
6. 自定义函数过滤：function check_file(){} 
7. WAF 防护产品：宝塔，阿里云盾，安全公司产品等

