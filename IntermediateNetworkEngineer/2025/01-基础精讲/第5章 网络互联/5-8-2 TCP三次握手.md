## 5-8 TCP和UDP协议

### 5-8-2 TCP三次握手

#### TCP三次握手建立连接

![image-20250306203551475](https://img.yatjay.top/md/20250306203551507.png)

**① 第一次握手（SYN）** 

客户端发起连接请求，发送SYN报文（SYN=1），携带随机生成的初始序列号（Seq=x），并进入`SYN_SENT`状态。  

> **示例**：客户端发送`SYN=1, Seq=1000`，类似“我要连接服务器，序列号从1000开始”。

**② 第二次握手（SYN+ACK）** 

服务器收到SYN后，回复SYN-ACK报文（SYN=1, ACK=1），确认客户端的序列号（Ack=x+1），同时生成自己的初始序列号（Seq=y），并进入`SYN_RCVD`状态。  

> **示例**：服务器回复`SYN=1, ACK=1, Ack=1001, Seq=2000`，表示“收到请求，我准备好用序列号2000通信”。

**③ 第三次握手（ACK）** 

客户端确认服务器的SYN-ACK报文，发送ACK报文（ACK=1），确认号Ack=y+1，自身序列号变为x+1（因SYN消耗一个序号），双方进入`ESTABLISHED`状态，开始数据传输。 <font color="red"> 第三次握手时，TCP载荷部分可以开始传数据</font>

> **示例**：客户端发送`ACK=1, Ack=2001`，表示“确认连接，开始传输数据”。



![image-20250306203612686](https://img.yatjay.top/md/20250306203612723.png)

以下是根据您提供的TCP三次握手过程整理的表格形式：

| 握手步骤 | 方向             | 报文内容                                                     | 状态转换            | 备注                                             | 示例                                                         |
| -------- | ---------------- | ------------------------------------------------------------ | ------------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| 第一次   | 客户端 -> 服务器 | <font color="red">SYN=1</font>, Seq=x                        | 客户端: `SYN_SENT`  | 客户端发起连接请求，x是客户端生成的初始序列号。  | SYN=1, Seq=1000<br>- 客户端发送序列号从1000开始的请求。<br/>- 我要连接服务器，序列号从1000开始 |
| 第二次   | 服务器 -> 客户端 | <font color="red">SYN=1, ACK=1</font>, Ack=x+1, Seq=y        | 服务器: `SYN_RCVD`  | 服务器回复确认，并提供自己的初始序列号y。        | SYN=1, ACK=1, Ack=1001, Seq=2000<br>- 服务器准备用序列号2000进行通信。<br/>- 收到请求，我准备好用序列号2000通信 |
| 第三次   | 客户端 -> 服务器 | <font color="red">ACK=1</font>, Ack=y+1<font color="red"><br> 第三次握手时，TCP载荷部分可以开始传数据</font> | 双方: `ESTABLISHED` | 客户端确认服务器的响应，双方准备好进行数据传输。 | ACK=1, Ack=2001<br>- 客户端确认连接，准备开始数据传输        |

注意：TCP通信过程中，确认帧ACK=1。TCP中只有第1个数据包即请求建立连接时发送的ACK=0，在连接建立后所有传送的报文段都必须把ACK置为1

#### TCP四次挥手断开连接

![image-20250306203626156](https://img.yatjay.top/md/20250306203626195.png)



| 挥手次数 | 方向          | 发送报文内容                                                 | 发送方状态变化           | 接收方状态变化           | 说明                                          |
| :------- | :------------ | :----------------------------------------------------------- | :----------------------- | :----------------------- | :-------------------------------------------- |
| 第一次   | 客户端→服务器 | 发送一个FIN报文段，序列号为seq=u                             | ESTABLISHED → FIN_WAIT_1 | ESTABLISHED → CLOSE_WAIT | 客户端完成数据发送，主动关闭连接              |
| 第二次   | 服务器→客户端 | 接收FIN，发送一个ACK报文段<br>序列号为seq=v，确认号为ack=u+1 | FIN_WAIT_1 → FIN_WAIT_2  | CLOSE_WAIT → LAST_ACK    | 服务器确认收到客户端的FIN报文段               |
| 第三次   | 服务器→客户端 | 发送一个FIN报文段<br/>序列号为seq=w，确认号为ack=u+1         | FIN_WAIT_2 → TIME_WAIT   | LAST_ACK → CLOSED        | 服务器完成数据发送，主动关闭连接              |
| 第四次   | 客户端→服务器 | 接收FIN，发送一个ACK报文段<br/>序列号为seq=u+1，确认号为ack=w+1 | TIME_WAIT → CLOSED       | CLOSED → CLOSED          | 客户端确认收到服务器的FIN报文段，连接完全关闭 |

注意：TCP通信过程中，确认帧ACK=1。TCP中只有第1个数据包即请求建立连接时发送的ACK=0，在连接建立后所有传送的报文段都必须把ACK置为1

#### 例题

##### 例题1

![image-20250306210805597](https://img.yatjay.top/md/20250306210805633.png)



##### 例题2

![image-20250306210837075](https://img.yatjay.top/md/20250306210837131.png)

解析：当TCP一端发起连接建立请求后，如果超时后没有收到对端的应答，会从同步已发送状态变为关
闭状态。TCP状态变化如右图。

##### 例题3

![image-20250306210856609](https://img.yatjay.top/md/20250306210856662.png)

![image-20250306210904724](https://img.yatjay.top/md/20250306210904764.png)

解析：

- 从netstat-n的输出信息中可以看出，本地主机192.168.0.200使用的端口号2011、2038、2052都不
  是公共端口号。
- 根据状态提示信息
  - 已经与主机128.105.129.30建立了连接
  - 与主机100.29.200.110正在断开连接，**发了FIN进入TIME_WAIT状态**
  - 与主机202.100.112.12已经建立了安全连接

##### 例题4

![image-20250306210920937](https://img.yatjay.top/md/20250306210920987.png)

解析：掌握如下几种扫描技术：

- <font color="red">完全连接扫描</font>：利用TCP/IP协议的三次握手连接机制，使源主机和目的主机的某个端口建立一次完整的连接。如果建立成功，则表明该端口开放。否则，表明该端口关闭。
- <font color="red">SYN扫描</font>：首先向目标主机发送连接请求，当目标主机返回响应后，立即切断连接过程，并查看响应情况。如果目标主机返回ACK信息，表示目标主机的该端口开放。**如果目标主机返回RST信息，表示该端口没有开放**。
- <font color="red">FIN扫描</font>：向目标主机的特定端口发送一个带有FIN标志的数据包。若目标端口是关闭状态，根据TCP/IP协议标准，目标主机会响应一个RST（复位）数据包。收到RST包则表明该端口是关闭的。**如果目标端是开放的，理论上不会返回任何响应包（即“静默”）**。没有响应通常被认为是端口开放的标志。

#### TCP序列号及确认号

##### 控制报文

如三次握手建立连接时，交互的就是控制报文

控制报文交互时，seq与对方的ack只是简单+1即可

![image-20250306212441575](https://img.yatjay.top/md/20250306212441616.png)

##### 数据报文

完成三次握手之后，交互的就是数据报文

- **序列号**（Sequence Number）：标识当前报文段第一个字节在数据流中的位置。例如，若初始序列号为1000，数据长度为100字节，下一报文段序列号为1100。 
- **确认号**（Acknowledgment Number）：仅在**ACK标志置1**时有效，表示接收方期望接收的下一个字节的序列号（**即已正确接收的数据末尾+1**）。

如PC1发送报文seq=201，其有效载荷数据部分为100字节，那么PC2回复时发送的ack=200+100=301（**即已正确接收的数据末尾+1**），反之也同理

![image-20250306212456489](https://img.yatjay.top/md/20250306212456531.png)

#### 例题

##### 例题1

![image-20250306211200285](https://img.yatjay.top/md/20250306211200325.png)

![image-20250306211209258](https://img.yatjay.top/md/20250306211209290.png)

解析：Telnet底层使用ASCII编码

- ack号：期望接收到对方下一个报文段的第一个数据字节的序号，A发送的ack=79，故希望B回送的序号是79，那么B回送的seq=79；
- A已经发了seq=42，一个字母是1个ASCIl（1个字节），B则希望他下一个发序号43的数据，则ack=43。

##### 例题2

![image-20250306211216702](https://img.yatjay.top/md/20250306211216740.png)

解析：主机A三次握手第一个seq=2000，**第三次握手seq=2001（开始传数据）**，而主机A断开连接时seq=8001，则说明序列号2001～8000在发送数据，合计6000字节。

##### 例题3

![image-20250306211232319](https://img.yatjay.top/md/20250306211232366.png)

![image-20250306211242935](https://img.yatjay.top/md/20250306211242973.png)

解析：

- 本题考查TCP三次握手，这是基础内容，必须掌握。三次握手第二次SYN和ACK都置1，ack等于下个报文的seq，即80。
- 注意：TCP通信过程中，确认帧ACK=1。TCP中只有第1个数据包即请求建立连接时发送的ACK=0，在连接建立后所有传送的报文段都必须把ACK置为1。ACK=0说明这是三次握手的第一次握手请求建立连接